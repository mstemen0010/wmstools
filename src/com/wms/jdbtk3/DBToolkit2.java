package com.wms.jdbtk3;// import org.gjt.mm.mysql.Driver;\import com.wms.jdbtk3.VDriver.DriverClass;import java.util.*;import com.wms.util.*;import com.wms.util.gui.GUILogInterface;/** *  *  * Static class to provide uniformed access to a virtual database and supporting *  *  * classes. The Virtual database acts a snap shot of an existent, remote, *  *  * and persistent database. The virtual database provides classes that virualize *  *  *  *  *  * Virtual Databases follow the following form: *  *  * <PRE> *  *  * DBToolKit ( 1 ) *  *  * ---> *  *  * VDBM ( 1 ) *  *  * ---> *  *  * VDatabase ( 0 to n ) *  *  * ---> *  *  * VTable ( 0 to n ) *  *  * ---> *  *  * VRecord ( 0 to n ) *  *  * ---> *  *  * VField ( 0 to n ) *  *  *  *  *  * </PRE> *  *  * @author Matt Stemen *  *   */public class DBToolkit2{    /**     * holds default information about the database and the default connection     * to the database.     */    private static DBUser dbUser = new DBUser(null);    /**     * static instance of the toolkit. This class follows a Singleton pattern     * and this member provides the singleton.     */    private static DBToolkit2 instance = null;    private VDBM vdbm = null;    // for now, it will be static, in the future we could 'front' for any number    // of dbms    /**     *      *      * A flag to let any databases that are loaded into the toolkit if they     * should     *      *      * to automatically try to create all the Tables in the database     *      *       */    private boolean autoBuild = false;    // private GesLog log = new GesLog("/tmp","DBToolkit.log");    private static WMSLog log = new WMSLog( "/tmp", "UDTConfig.log" );    private static DriverClass defaultDriverClass = DriverClass.Derby;    // Singleton, need a private constructor    /**     *      *      * Private contruct due to the nature of the Singleton     *      *       */    private DBToolkit2()    {}    /**     *      *      * Method that provides static access to the singleton of the toolkit     *      *      * @return the static memeber of the singleton     *      *       */    public static DBToolkit2 getInstanceNoInit()    {	    if( instance == null )	    {		    instance = new DBToolkit2();	    }	    return instance;    }        public static DBToolkit2 getInstance()    {        if(instance == null)        {            instance = new DBToolkit2();            instance.init();        }        return (instance);    }    // main is here for testing    /**     *      *      * only present for testing purposes     *      *      * @param args     *            any args needed by the main     *      *      * @throws Exception     *             all mains throw base Exception to the JVM     *      *       */    public static void main(String args[]) throws Exception    {    /*     *      *      * //DBToolkit dbt = DBToolkit.getInstance();     *      *      *      *      *      * log.write("Creating virtual database entities");     *      *      * dbt.showTables("vts"); dbt.describeTable("vts", "devices"); VDBM dbm =     *      *      * dbt.getDbm(); VDatabase vdb = dbm.findDatabase("vts");     *      *  // vdb.showTables(); // VTable elements_table = vdb.getTable(     *      *      * "devices" ); // elements_table.describe(); //     *      *      * elements_table.populate(); // elements_table.dumpTable();     *      *      *      *      *       */    }    /**     *      *      * Method to translate database types to java class types that are used in     * JDBC     *      *      * Currently this is geared to MySql, but should access a simlar method     * through     *      *      * the VDBM that is specific to a particular DBMS ( e.g. Oracle, MySql, etc )     *      *      * @param db_type     *            Native data type that is used by a particular database field     *            (i.e.     *      *      * int(10), tinytext, etc)     *      *      * @return a String that is the name of a java Class Type     *      *  ( String, Integer, Long, etc)     *      *       */    public String getTypeForString(String db_type)    {        String return_type = db_type;        if(db_type.indexOf("unsigned") >= 0 && db_type.indexOf("int") >= 0)            return_type = "Integer";        else if(db_type.indexOf("int") >= 0)            return_type = "Integer";        else if(db_type.indexOf("tinytext") >= 0)            return_type = "String";        else if(db_type.indexOf("varchar") >= 0)            return_type = "String";        else if(db_type.indexOf("bigint") >= 0)            return_type = "Long";        return return_type;    }    /**     *      *      * Interal method to set up the defaults for the toolkit. In the future     * these     *      *      * default settings should be learned from a Java property.     *      *       */    private void init()    {        vdbm = new VDBM();        vdbm.setAutoBuild(this.autoBuild);        dbUser = new DBUser(null);        dbUser.setDbName("vts");        dbUser.setName("root");        dbUser.setPasswd("udt");        dbUser.setServerName("localhost");        String serverName = "localhost";        StringBuffer url = new StringBuffer("jdbc:mysql://");        url.append(serverName).append("/").append(dbUser.getDb_name());        // a JDBC url        log.write("Got database URL: " + url.toString());        VDatabase db = vdbm.createDatabase("vts",url.toString(), defaultDriverClass);        // db.setDriverName("org.gjt.mm.mysql.Driver");        db.setDriverName("com.mysql.jdbc.Driver");        dbUser.setDbUrl(url.toString());        db.setDbUrl(url.toString());        db.addUser(dbUser);        db.setDbUser(dbUser);        // the follow should be optional, or user defined..        if(vdbm.getAutoBuild())        {            db.build();            db.populate();            db.learnTopolgy();        }        vdbm.addDatabase(db);    }    public void setLog(WMSLog log)    {        this.log = log;    }    public WMSLog getLog()    {        return log;    }    /**     *      *      * Method to access the VDBM for the toolkit. The VDBM is geared to a     * partical RDBMS     *      *  ( i.e. MySql, Oracle, etc )     *      *      * @return The current VDBM for the toolkit.     *      *       */    public VDBM getDbm()    {        return vdbm;    }    public VDBM getDbm(DBUser user, GUILogInterface log)    {        VDBM ldbm = new VDBM(user,log);        VDatabase db = ldbm.createDatabase(user.getDb_name(),user.getDbUrl(), defaultDriverClass );        // db.setDriverName("org.gjt.mm.mysql.Driver");        db.setDriverName("com.mysql.jdbc.Driver");        db.addUser(user);        db.setDbUser(user);        // the follow should be optional, or user defined..        if(ldbm.getAutoBuild())        {            db.build();            db.populate();            db.learnTopolgy();        }        ldbm.addDatabase(db);        return ldbm;    }    public VDBM getDbm(DBUser user,WMSLog log)    {        VDBM ldbm = new VDBM(user,log);        VDatabase db = ldbm.createDatabase(user.getDb_name(),user.getDbUrl(), defaultDriverClass );        // db.setDriverName("org.gjt.mm.mysql.Driver");        db.setDriverName("com.mysql.jdbc.Driver");        db.addUser(user);        db.setDbUser(user);        // the follow should be optional, or user defined..        if(ldbm.getAutoBuild())        {            db.build();            db.populate();            db.learnTopolgy();        }        ldbm.addDatabase(db);        return ldbm;    }    /**     *      *      * Behaves like a SQL: "Show Tables" for a given Virtual Databse. which     * currently printed to stdout.     *      *      * @param db_name     *            database name that is currently loaded into the VDBM that you     *      *      * wish to see the tables for     *      *       */    public void showTables(String db_name)    {        VDatabase db = vdbm.findDatabase(db_name);        if(db == null)            return;        db.showTables();    }    /**     *      *      * create a Virtual table within the Virtual database named, and learn the     * basic     *      *      * structure of its fields and their datatypes.     *      *      * @param db_name     *            Database that contains the desired table. This database name     *            should     *      *      * map 1 to 1 to a virtual database that is currently know about by     *      *      * the VDBM     *      *      * @param table_name     *            The name of the table that is to be learned by the Virtual     *            database     *      *       */    public void buildTable(String db_name,String table_name)    {        VDatabase db = vdbm.findDatabase(db_name);        VTable t = db.getTable(table_name);        if(t == null)            return;        t.build();    }    /**     *      *      * All tables are stored in a given Virtual database in a Hashtable. This     * method     *      *      * provides access to get an enumeration of keys to all stored tables in the     * named     *      *      * database     *      *      * @param db_name     *            Database to retreive the table keys from     *      *      * @return Enumeration of all keys to all tables in the named database     *      *       */    public Enumeration getTables(String db_name)    {        Enumeration enumer = null;        VDatabase db = vdbm.findDatabase(db_name);        if(db != null)        {            enumer = db.getTables();        }        return enumer;    }    /**     *      *      * Method to retrieve a reference to a particular table in a particular     * database     *      *      * @param db_name     *            Name of the database to get the table from     *      *      * @param table_name     *            the table to be retrieved from the named database     *      *      * @return either returns a VTable reference or null if the table was not     *         found     *      *       */    public VTable getTable(String db_name,String table_name)    {        VDatabase db = vdbm.findDatabase(db_name);        VTable t = db.getTable(table_name);        if(t == null)            return null;        return t;    }    /**     *      *      * Acts as a SQL "describe" of a given table in a named database.     *      *      * @param db_name     *            Database that contains the table to be described     *      *      * @param table_name     *            The table to be described     *      *       */    public void describeTable(String db_name,String table_name)    {        VDatabase db = vdbm.findDatabase(db_name);        VTable t = db.getTable(table_name);        if(t == null)            return;        t.describe();    }    /**     *      *      * set the autobuild flag to reflect whether or not virtual databases should     * try     *      *      * and build and populate all the tables in the real databases. If this is     * not set,     *      *      * Tables may be created and built one at a time, or programatically     *      *      * @param autoBuild     *            the value that the autobuild flag should be set to     *      *       */    public void setAutoBuild(boolean autoBuild)    {        this.autoBuild = autoBuild;    }    /**     *      *      * Method to gain access to the autobuild flag.     *      *      * @return the autobuild flag     *      *       */    public boolean getAutoBuild()    {        return autoBuild;    }    public void setUser(DBUser user)    {        this.dbUser = user;    }    public void setVDBM(VDBM dbm)    {        this.vdbm = dbm;    }}